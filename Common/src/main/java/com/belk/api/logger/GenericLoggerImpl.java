package com.belk.api.logger;

import java.util.HashMap;

import org.apache.log4j.Level;
import org.apache.log4j.Logger;

import com.belk.api.constants.CommonConstants;
import com.belk.api.constants.ErrorConstants;
import com.belk.api.util.CommonUtil;
import com.belk.eil.logging.utils.appender.message.LogProcessorMessage;

/**
 * Implementation class for generic logger.
 * 
 * Update: correlationId has been added to all the methods as part of CR:
 * CR_BELK_API_1. correlationId is used to track the logs at an enterprise
 * level.
 * 
 * Update: This class has been updated to Implement the EnterpriseLogger
 * framework, as part of CR: April 2014_Release
 * 
 * @author Mindtree
 * @date Jul 23, 2013
 * 
 */
public class GenericLoggerImpl implements GenericLogger {
	/**
	 * creating instance of logger.
	 */
	private Logger logger;


	/**
	 * @param loggerName
	 *            Name of the logger to be written into
	 */
	public GenericLoggerImpl(final String loggerName) {
		this.logger = Logger.getLogger(loggerName);
	}

	@Override
	public final void debug(final String msg, final String correlationId) {

		if (this.isDebugEnabled()) {
			this.logger.debug(msg + " Line No is: "
					+ Thread.currentThread().getStackTrace()[2].getLineNumber()
					+ " -- CorrelationId : " + correlationId);
		}
	}

	@Override
	public final void info(final String msg, final String correlationId) {

		if (this.isInfoEnabled()) {
			this.logger.info(msg + " Line No : "
					+ Thread.currentThread().getStackTrace()[2].getLineNumber()
					+ " -- Correlation Id is: " + correlationId);
		}
	}

	@Override
	public final void warn(final String msg, final String correlationId) {

		this.logger.warn(msg + " -- CorrelationId is " + correlationId);
	}
	
	
	/**
	 * The method to log the messages to API logger and Enterprise Logger
	 *  with throwable and having log level as error.
	 * @param error for error message
	 * @param correlationId for tracking the request
	 */
	@Override
	public final void error(final Throwable error, final String correlationId) {

		// To log the message while handling an exception
	this.logger.error(this.enterpriseErrorMessageForExceptionHandling(
			ErrorConstants.ERRORDESC_MESSAGE + " -- CorrelationId : "
				+ correlationId , correlationId , error , null) , error);
		
		// Exception generated by Framework (Other than ServiceException,BaseException and AdapterException 
		// are logged only in the ApiServices Logs and doesn't go into ELF

	}

	/**
	 * The method to log the messages to API logger and Enterprise Logger 
	 * with exception and having log level as error.
	 * @param apiErrorMessage for error message coming from calling methods
	 * @param error for Base Exception Throwable object
	 * @param correlationId for tracking the request
	 */
	@Override
	public final void error(final String apiErrorMessage, final Exception error,
			final String correlationId) {
		// Get the response as XML String from BaseException object for logging into ELF
		final String responseXMLMessageForELF = CommonUtil.generateResponseXMLString(error, error.getClass(), correlationId);
		// Creating the ELF Appender Message
		final LogProcessorMessage processMessageELF = this.enterpriseErrorMessageForExceptionHandling(apiErrorMessage
				+ " -- correlationId : " + correlationId,
				correlationId, error, responseXMLMessageForELF);
		// To log the message into ELF and also ApiServices Logs while handling an exception
		this.logger.error(processMessageELF, error);
	}


	@Override
	public final void fatal(final String msg) {
		this.logger.fatal(msg);
	}

	@Override
	public final long logMethodEntry(final String correlationId) {
		final long startTime = System.currentTimeMillis();
		if (this.isDebugEnabled()) {
			this.logger.debug("Entering : "
					+ LoggingHelper.getFormattedSource()
					+ " Entry Time in msec : " + startTime
					+ " -- correlation Id : " + correlationId);
		}
		return startTime;
	}

	@Override
	public final void logMethodExit(final long startTime,
			final String correlationId) {
		final long endTime = System.currentTimeMillis();
		if (this.isDebugEnabled()) {
			this.logger.debug("Exiting : " + LoggingHelper.getFormattedSource()
					+ " Exit Time in msec : " + endTime + " Time Taken :"
					+ (endTime - startTime) + " -- Correlation Id : "
					+ correlationId);
		}
	}

	@Override
	public final boolean isDebugEnabled() {
		return this.logger.isDebugEnabled();
	}

	@Override
	public final boolean isErrorEnabled() {
		return this.logger.isEnabledFor(Level.ERROR);
	}

	@Override
	public final boolean isFatalEnabled() {
		return this.logger.isEnabledFor(Level.FATAL);
	}

	@Override
	public final boolean isInfoEnabled() {
		return this.logger.isInfoEnabled();
	}

	@Override
	public final boolean isWarnEnabled() {
		return this.logger.isEnabledFor(Level.WARN);
	}

	
	/**
	 * @param apiErrormessage
	 *            message that we log
	 * @param correlationId for tracking the request
	 * 
	 * @param exception
	 *            Exception (Optional,for debugging exception object is passed as null and
	 *            for error)
	 * @param xmlResponseELFMessage XML Response message for populating the ELF Body Message           
	 * @return LogProcessorMessage
	 * 
	 * The method to log the message while handling an exception which
	 * contains payload message type, message body, correlationId,
	 * message header etc.,set in a parameterMap that are specified as system variables
	 * and returns a processor message that handles the parameterMap and 
	 * the message that we log in API
	 * 
	 * 
	 **/

	private LogProcessorMessage enterpriseErrorMessageForExceptionHandling(
			final String apiErrormessage, final String correlationId, 
					final Throwable exception, final String xmlResponseELFMessage) {
		// ELF Logger Message Object
		LogProcessorMessage logProcessorMessage = null;
		
		final HashMap<String, Object> parameterMap = new HashMap<String, Object>();
		// The message type of the payload that the JAVA/J2EE app is dealing
		// with
		parameterMap.put(CommonConstants.PAYLOAD_MESSAGE_TYPE,
				CommonConstants.PAYLOAD_MESSAGE_TYPE_VALUE);
		// The message format of the payload that the JAVA/J2ee app is dealing
		// with
		parameterMap.put(CommonConstants.PAYLOAD_MESSAGE_DOMAIN,
				CommonConstants.MEDIA_TYPE_XML);
		// The correlationId of the payload message that the JAVA/J2EE app is
		// dealing with.API Services populates the correlation id 
		// received from Data Power(Gateway)
		parameterMap.put(CommonConstants.PAYLOAD_MESSAGE_CORRELATIONID,
				correlationId);
		// The body of the payload message that the JAVA/J2EE app is dealing
		// Populated only if not null
		if (xmlResponseELFMessage != null) {
		parameterMap.put(CommonConstants.PAYLOAD_MESSAGE_BODY, xmlResponseELFMessage);
		}
		// The charset of the payload message that the JAVA/J2EE app is dealing
		// with
		parameterMap.put(CommonConstants.PAYLOAD_MESSAGE_CCSID, System
				.setProperty(CommonConstants.ENCRYPTION,
						CommonConstants.UCS_TRANSFORMATION_FORMAT));
		// The encoding of the payload message that the JAVA/J2EE app is dealing
		// with
		parameterMap.put(CommonConstants.PAYLOAD_MESSAGE_ENCODING, System
				.setProperty(CommonConstants.ENCRYPTION,
						CommonConstants.UCS_TRANSFORMATION_FORMAT));
		// The parent correlation Id of the pauload message that the JAVA/J2EE
		// app is dealing with.Applicable for Distributed Transactions Only
		// API Services doesn't populate the value
		parameterMap.put(CommonConstants.PAYLOAD_MESSAGE_PARENT_CORRELATIONID,
				null);
		// The header of the payload message that the JAVA/J2EE app is dealing
		// with
		parameterMap.put(CommonConstants.PAYLOAD_MESSAGE_HEADER, null);

		if (exception.getMessage() != null) {
			// If the Exception object is not null then it is  a case of 
			// Error and ELF will accept the exception object
			// Exception is passed as null as to not log the stack trace
			// on BEAM Console			
			
			logProcessorMessage = new LogProcessorMessage(
					apiErrormessage + ":" + exception.getMessage() , parameterMap, null);
		} else {
			// If the Exception object is null then it is a case of debug and ELF will not
			// accept the Exception object
			logProcessorMessage = new LogProcessorMessage(apiErrormessage + xmlResponseELFMessage, parameterMap);
		}

		return logProcessorMessage;
	}

	@Override
	public final void setLoggerLevel(final String logLevel) {
		this.logger.setLevel(Level.toLevel(logLevel));
	}
	
}